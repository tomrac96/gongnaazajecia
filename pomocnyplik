#define ROZMIAR_PLANSZY 19 // Rozmiar standardowej planszy w Go

typedef struct {
    int wiersz;
    int kolumna;
} Pole;

typedef struct {
    Pole z;
    Pole na;
} Ruch;

typedef struct ListaRuchow {
    Ruch ruch;
    struct ListaRuchow* nastepny;
} ListaRuchow;

typedef int Plansza[ROZMIAR_PLANSZY][ROZMIAR_PLANSZY];

ListaRuchow* generujRuchyGo(Plansza plansza, int gracz) {
    ListaRuchow* listaRuchow = NULL;

    for (int wiersz = 0; wiersz < ROZMIAR_PLANSZY; wiersz++) {
        for (int kolumna = 0; kolumna < ROZMIAR_PLANSZY; kolumna++) {
            if (plansza[wiersz][kolumna] == 0) { // Sprawdzenie, czy pole jest puste
                Ruch ruch = {{wiersz, kolumna}, {-1, -1}}; // Tworzenie struktury ruchu

                // Sprawdzenie czy wykonujący ruch gracz może postawić kamień na danym polu
                // i dodanie tego ruchu do listy
                if (czyMoznaPostawicKamien(plansza, gracz, wiersz, kolumna)) {
                    listaRuchow = dodajRuch(listaRuchow, ruch);
                }
            }
        }
    }

    return listaRuchow;
}

// Funkcja sprawdzająca, czy gracz może postawić kamień na danym polu
int czyMoznaPostawicKamien(Plansza plansza, int gracz, int wiersz, int kolumna) {
    // Implementacja logiki sprawdzającej czy na dane pole można postawić kamień
    // (np. czy ruch nie narusza reguły samobójstwa, czy nie jest suicydalny itp.)
    // Zwraca 1 jeśli można postawić kamień, 0 w przeciwnym razie
    // Ta funkcja jest kluczowa i musi uwzględniać wiele reguł gry Go
    // Tutaj przedstawiono tylko szkic tej funkcji.





#define ROZMIAR_PLANSZY 19 // Rozmiar standardowej planszy w Go

// Struktura opisująca pole na planszy
typedef struct {
    int wiersz;
    int kolumna;
} Pole;

// Struktura opisująca ruch
typedef struct {
    Pole z;
    Pole na;
} Ruch;

// Struktura listy ruchów
typedef struct ListaRuchow {
    Ruch ruch;
    struct ListaRuchow* nastepny;
} ListaRuchow;

// Plansza do gry Go
typedef int Plansza[ROZMIAR_PLANSZY][ROZMIAR_PLANSZY];

// Funkcja sprawdzająca, czy można postawić kamień na danym polu
int czyMoznaPostawicKamien(Plansza plansza, int gracz, int wiersz, int kolumna) {
    if (plansza[wiersz][kolumna] != 0) {
        // Pole jest już zajęte, nie można postawić kamienia
        return 0;
    }

    // TODO: Implementacja reguł gry Go dla możliwości postawienia kamienia
    // Przykładowa logika:
    // - Sprawdzenie, czy postawienie kamienia nie powoduje samobójstwa
    // - Sprawdzenie, czy ruch jest legalny zgodnie z zasadami gry Go

    return 1; // Zwrócenie 1, jeśli można postawić kamień
}

// Funkcja generująca ruchy dla gracza na planszy Go
ListaRuchow* generujRuchyGo(Plansza plansza, int gracz) {
    ListaRuchow* listaRuchow = NULL;

    for (int wiersz = 0; wiersz < ROZMIAR_PLANSZY; wiersz++) {
        for (int kolumna = 0; kolumna < ROZMIAR_PLANSZY; kolumna++) {
            if (czyMoznaPostawicKamien(plansza, gracz, wiersz, kolumna)) {
                Ruch ruch = {{wiersz, kolumna}, {-1, -1}}; // Tworzenie struktury ruchu
                // Dodanie ruchu do listy ruchów
                listaRuchow = dodajRuch(listaRuchow, ruch);
            }
        }
    }

    return listaRuchow;
}





#define NIE 0
#define TAK 1

// Funkcja sprawdzająca czy dany ruch jest prawidłowy
int czy_prawidlowy_ruch(plansza teatr_wojenny, int i, int j) {
    if (i >= 0 && i < SZEROKOSC_PLANSZY && j >= 0 && j < WYSOKOSC_PLANSZY &&
        teatr_wojenny.plain[i][j] == PUSTE) {
        return TAK;
    } else {
        return NIE;
    }
}
// Funkcja generująca możliwe ruchy dla aktualnego gracza
void generuj_ruchy(plansza teatr_wojenny) {
    printf("\nLista mozliwych ruchow:\n");
    for (int i = 0; i < SZEROKOSC_PLANSZY; ++i) {
        for (int j = 0; j < WYSOKOSC_PLANSZY; ++j) {
            if (czy_prawidlowy_ruch(teatr_wojenny, i, j)) {
                printf("Mozliwy ruch: %c%d\n", 'A' + i, j);
                // Tutaj możesz zdecydować, co robić z każdym znalezionym ruchem
                // Możesz je przechowywać, wyświetlać lub podejmować decyzje na ich podstawie
            }
        }
    }
}
