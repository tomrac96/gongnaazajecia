#define ROZMIAR_PLANSZY 19 // Rozmiar standardowej planszy w Go

typedef struct {
    int wiersz;
    int kolumna;
} Pole;

typedef struct {
    Pole z;
    Pole na;
} Ruch;

typedef struct ListaRuchow {
    Ruch ruch;
    struct ListaRuchow* nastepny;
} ListaRuchow;

typedef int Plansza[ROZMIAR_PLANSZY][ROZMIAR_PLANSZY];

ListaRuchow* generujRuchyGo(Plansza plansza, int gracz) {
    ListaRuchow* listaRuchow = NULL;

    for (int wiersz = 0; wiersz < ROZMIAR_PLANSZY; wiersz++) {
        for (int kolumna = 0; kolumna < ROZMIAR_PLANSZY; kolumna++) {
            if (plansza[wiersz][kolumna] == 0) { // Sprawdzenie, czy pole jest puste
                Ruch ruch = {{wiersz, kolumna}, {-1, -1}}; // Tworzenie struktury ruchu

                // Sprawdzenie czy wykonujący ruch gracz może postawić kamień na danym polu
                // i dodanie tego ruchu do listy
                if (czyMoznaPostawicKamien(plansza, gracz, wiersz, kolumna)) {
                    listaRuchow = dodajRuch(listaRuchow, ruch);
                }
            }
        }
    }

    return listaRuchow;
}

// Funkcja sprawdzająca, czy gracz może postawić kamień na danym polu
int czyMoznaPostawicKamien(Plansza plansza, int gracz, int wiersz, int kolumna) {
    // Implementacja logiki sprawdzającej czy na dane pole można postawić kamień
    // (np. czy ruch nie narusza reguły samobójstwa, czy nie jest suicydalny itp.)
    // Zwraca 1 jeśli można postawić kamień, 0 w przeciwnym razie
    // Ta funkcja jest kluczowa i musi uwzględniać wiele reguł gry Go
    // Tutaj przedstawiono tylko szkic tej funkcji.





#define ROZMIAR_PLANSZY 19 // Rozmiar standardowej planszy w Go

// Struktura opisująca pole na planszy
typedef struct {
    int wiersz;
    int kolumna;
} Pole;

// Struktura opisująca ruch
typedef struct {
    Pole z;
    Pole na;
} Ruch;

// Struktura listy ruchów
typedef struct ListaRuchow {
    Ruch ruch;
    struct ListaRuchow* nastepny;
} ListaRuchow;

// Plansza do gry Go
typedef int Plansza[ROZMIAR_PLANSZY][ROZMIAR_PLANSZY];

// Funkcja sprawdzająca, czy można postawić kamień na danym polu
int czyMoznaPostawicKamien(Plansza plansza, int gracz, int wiersz, int kolumna) {
    if (plansza[wiersz][kolumna] != 0) {
        // Pole jest już zajęte, nie można postawić kamienia
        return 0;
    }

    // TODO: Implementacja reguł gry Go dla możliwości postawienia kamienia
    // Przykładowa logika:
    // - Sprawdzenie, czy postawienie kamienia nie powoduje samobójstwa
    // - Sprawdzenie, czy ruch jest legalny zgodnie z zasadami gry Go

    return 1; // Zwrócenie 1, jeśli można postawić kamień
}

// Funkcja generująca ruchy dla gracza na planszy Go
ListaRuchow* generujRuchyGo(Plansza plansza, int gracz) {
    ListaRuchow* listaRuchow = NULL;

    for (int wiersz = 0; wiersz < ROZMIAR_PLANSZY; wiersz++) {
        for (int kolumna = 0; kolumna < ROZMIAR_PLANSZY; kolumna++) {
            if (czyMoznaPostawicKamien(plansza, gracz, wiersz, kolumna)) {
                Ruch ruch = {{wiersz, kolumna}, {-1, -1}}; // Tworzenie struktury ruchu
                // Dodanie ruchu do listy ruchów
                listaRuchow = dodajRuch(listaRuchow, ruch);
            }
        }
    }

    return listaRuchow;
}
